//
//  NSDictionaryAsConst.h
//  ExploitingC
//
//  Created by Richard Mayer on 24/06/2013.
//  Copyright (c) 2013 Richard Mayer. All rights reserved.
//

#import <Foundation/Foundation.h>

// Often useful for working with a C array, but can't be used in this particular
// demo because sizeof() won't work for use here - the contents of the const
// struct array[] is defined in the .m, therefore contents are unknown at
// compile time.
//
// Trying to use this macro (by implication sizeof()) on our data array would
// raise a compile error:
// > invalid application of 'sizeof' to incomplete type 'const struct fruitDefsArray[]'
#define SIZE_OF(MY_C_ARRAY) sizeof(MY_C_ARRAY) / sizeof(MY_C_ARRAY[0])

// Instead, because the array is a constant anyway, we can just hardcode it's
// size.
#define FRUIT_TYPES_COUNT 3
#define SIZEOF_FRUIT_DEFS_ARRAY FRUIT_TYPES_COUNT +1  // regular types plus one for "Unknown", which can be used a a sentinel

// Next we define an enum of fruit types
typedef enum {
    // -------------------------------------------------------------------------
    // These are the "regular" enums (the actual types). There should be
    // %FRUIT_TYPES_COUNT% of these! Remember to update the item count when
    // adding or removing types.
    //
    // They should also be consecutive enumeration values, beginning with 0
    // That's important, because their value will be used to index the data
    // array (the one declared below). Good practice would be to write a test
    // for that.
	FruitTypeApple,
    FruitTypePineapple,
    FruitTypeBanana,
    // -------------------------------------------------------------------------
    
    // -------------------------------------------------------------------------
    // This is optional. It can be used as a sentinel to identify the last
    // element of an array (that will be declared below).
    // However, it's fairly redundant in the light of FRUIT_TYPES_COUNT
	FruitTypeUnknown = FRUIT_TYPES_COUNT,
    // -------------------------------------------------------------------------
    
    // -------------------------------------------------------------------------
    // These are optional helpers. In order to facilitate "for" loop enumeration
    // these 'aliases' mark the first and last items to iterate through.
    //
    // Without them, you could rely on FruitTypeUnknown being at a specific
    // location in the enum, but that's too error prone. With these, it's a
    // piece of gateaux to just do:
    //   for (FruitType f = FruitTypeFirst; f <= FruitTypeLast; ++f) {}
    //
    // In turn, it's then also a breeze to verify (either internally or from a
    // test) that:
    //   (FruitTypeLast - FruitTypeFirst + 1 == FRUIT_TYPES_COUNT)
    // -------------------------------------------------------------------------
    FruitTypeFirst = FruitTypeApple,
    FruitTypeLast = FruitTypeBanana,
    
    // -------------------------------------------------------------------------
    // And finally, just for the hell of it, another optional alias
    FruitTypeDefault = FruitTypeApple
    // -------------------------------------------------------------------------    
    
} FruitType;

// Next, define a struct, indexed by the enum type, with whatever props are
// associated with the enum type.
//
// Of course, you could also go crazy here and nest as many structs as deep as
// you want. Better to keep it as simple as possible though, else the
// .m definitions start to get cumbersome and difficult to follow.
typedef struct {
	FruitType		type;
	NSString*		name;
	NSString*		colour; // It's important to spell colour correctly ;-)
} FruitDefinition;

// And declare a constant array of them
extern const FruitDefinition kFruitDefsArray [SIZEOF_FRUIT_DEFS_ARRAY];

@interface NSDictionaryAsConst : NSObject

- (NSDictionary*)dictionaryForFruit:(FruitType)aFruit;

@end
