//
//  Using_C_ArraysTests.m
//  Using C ArraysTests
//
//  Created by Richard Mayer on 24/06/2013.
//  Copyright (c) 2013 Richard Mayer. All rights reserved.
//

#import "ExploitingCTests.h"

@implementation ExploitingCTests

- (void)setUp
{
    [super setUp];
    
    // Set-up code here.
    STAssertNoThrow(self.unitUnderTest = [[NSDictionaryAsConst alloc] init],
                    @"Test failed. The unit under test raised an exception, whilst being instantiated.");    
}

- (void)tearDown
{
    // Tear-down code here.
    self.unitUnderTest = nil;

    [super tearDown];
}

// This is double security. In actual fact 'init' already does a self test, but
// from a testing point of view we don't assume that
-(void)testEnumAndArrayConsistency
{
    NSUInteger fruitTypeCount = 0;

    NSLog(@"Testing the correct structure of enum FruitType...");
    
    // There is an ...Unknown enumeration = FRUIT_TYPES_COUNT (ie. it comes immediately after the regular ones)
    NSLog(@"FruitTypeUnknown = %d (expect -1)", FruitTypeUnknown);
    BOOL isFruitTypeUnknownGood = (FruitTypeUnknown == FRUIT_TYPES_COUNT);
    STAssertTrue(isFruitTypeUnknownGood, nil);
    
    // There is a ...First enumeration = 0
    NSLog(@"FruitTypeFirst = %d (expect 0)", FruitTypeFirst);
    BOOL isFruitTypeFirstGood = (FruitTypeFirst == 0);
    STAssertTrue(isFruitTypeFirstGood, nil);
    
    // There is an ...Last enumeration > 0
    NSLog(@"FruitTypeLast = %d (expect 0 or larger)", FruitTypeLast);
    BOOL isFruitTypeLastGood = (FruitTypeLast >= 0);
    STAssertTrue(isFruitTypeLastGood, nil);
    
    BOOL isEnumCountDeclarationValidated = NO;
    if (isFruitTypeFirstGood && isFruitTypeLastGood)
    {
        // The FRUIT_TYPES_COUNT define is in sync with the actual number of enums?
        for (FruitType userDataType = FruitTypeFirst;
             userDataType <= FruitTypeLast;
             ++userDataType)
        {
            fruitTypeCount++;
            // For the log out, knock 1 off the fruit type count, just so that the
            // message "looks" correct. Although perfectly valid "Fruit typ 1 with
            // enum val 0" would seem wrong to the casual observer!)
            NSLog(@"Fruit type number %d has enum val %d", fruitTypeCount-1, userDataType);
        }

        isEnumCountDeclarationValidated = (fruitTypeCount = FRUIT_TYPES_COUNT);
        STAssertTrue(isEnumCountDeclarationValidated,
                     @"The object under test declares %d types (FRUIT_TYPES_COUNT), but between FruitTypeFirst (%d) and FruitTypeLast (%d) there are %d enumerations. Perhaps someone forgot to update FRUIT_TYPES_COUNT or the First/Last aliases are incorrect?", FRUIT_TYPES_COUNT, FruitTypeFirst, FruitTypeLast, FruitTypeLast-FruitTypeFirst+1);
     }
    
    if (isEnumCountDeclarationValidated)
    {
        // Test that enumerations map onto the array of structs
        int sizeOfFruitDefsArray = (sizeof(kFruitDefsArray) / sizeof(kFruitDefsArray[0]));
        
        STAssertTrue(SIZEOF_FRUIT_DEFS_ARRAY == sizeOfFruitDefsArray,
        @"Fruits array size doesn't correlate with the number of types defined by FruitTypes");
        
        STAssertTrue(SIZEOF_FRUIT_DEFS_ARRAY <= sizeOfFruitDefsArray,
        @"Fruits array size %d is larger than expected (%d) - potential double defined types?", sizeOfFruitDefsArray, SIZEOF_FRUIT_DEFS_ARRAY);
        
        STAssertTrue(SIZEOF_FRUIT_DEFS_ARRAY >= sizeOfFruitDefsArray,
        @"Fruits array size %d is smaller than expected (%d) - definitions may be missing for some types.", sizeOfFruitDefsArray, SIZEOF_FRUIT_DEFS_ARRAY);
        
        NSLog(@"There are %d fruit type enums defined (incl. 'Unknown'), corresponding to %d array elements to store fruit descriptions", sizeOfFruitDefsArray, SIZEOF_FRUIT_DEFS_ARRAY);
    }

}

- (void)testFruitTypeApple
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeApple];
    
    // The Test
    if (self.unitUnderTest != nil)
    {
        NSDictionary* result = [self.unitUnderTest dictionaryForFruit:FruitTypeApple];
        
        // Evaluation 1
        // Check that the wrapper dict is correct
        STAssertNotNil([result objectForKey:fruitTypeIndex], @"SHIT");
        
        // Evaluation 2
        // Check that the contents are correc
        NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
        
        NSLog(@"FruitTypeApple's name is '%@' it's colour is '%@'",
              [fruitTypeDefn objectForKey:@"Name"],
              [fruitTypeDefn objectForKey:@"Colour"]);
    }
    
    else {
        STFail(@"Test not executed because unit under test not initialised");
    }
}

- (void)testFruitTypeBanana
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeBanana];
    
    // The Test    
    if (self.unitUnderTest != nil)
    {
        NSDictionary* result = [self.unitUnderTest dictionaryForFruit:FruitTypeBanana];
        
        // Evaluation 1
        // Check that the wrapper dict is correct
        STAssertNotNil([result objectForKey:fruitTypeIndex], @"SHIT");
        
        // Evaluation 2
        // Check that the contents are correc
        NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
        
        NSLog(@"FruitTypeBanana's name is '%@' it's colour is '%@'",
              [fruitTypeDefn objectForKey:@"Name"],
              [fruitTypeDefn objectForKey:@"Colour"]);
    }
    
    else {
        STFail(@"Test not executed because unit under test not initialised");
    }
}

- (void)testFruitTypeDefault
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeDefault];
    
    // The Test    
    if (self.unitUnderTest != nil)
    {
        NSDictionary* result = [self.unitUnderTest dictionaryForFruit:FruitTypeDefault];
        
        // Evaluation 1
        // Check that the wrapper dict is correct
        STAssertNotNil([result objectForKey:fruitTypeIndex], @"SHIT");
        
        // Evaluation 2
        // Check that the contents are correc
        NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
        
        NSLog(@"FruitTypeDefault's name is '%@' it's colour is '%@'",
              [fruitTypeDefn objectForKey:@"Name"],
              [fruitTypeDefn objectForKey:@"Colour"]);
    }
    
    else {
        STFail(@"Test not executed because unit under test not initialised");
    }
}

- (void)testFruitTypeUnknown
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeUnknown];
    
    // The Test    
    if (self.unitUnderTest != nil)
    {
        NSDictionary* result = [self.unitUnderTest dictionaryForFruit:FruitTypeUnknown];
        
        // Evaluation 1
        // Check that the wrapper dict is correct
        STAssertNil([result objectForKey:fruitTypeIndex], @"SHIT");
        
        // Evaluation 2
        // Check that the contents are correc
        NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
        
        NSLog(@"FruitTypeUnknown's name is '%@' it's colour is '%@'",
              [fruitTypeDefn objectForKey:@"Name"],
              [fruitTypeDefn objectForKey:@"Colour"]);
    }
    
    else {
        STFail(@"Test not executed because unit under test not initialised");
    }
}

- (void)testFruitTypeInvalid
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:INT16_MIN];
    
    // The Test
    if (self.unitUnderTest != nil)
    {
        NSDictionary* result = [self.unitUnderTest dictionaryForFruit:INT16_MIN];
        
        // Evaluation 1
        // Check that the wrapper dict is correct
        STAssertNil([result objectForKey:fruitTypeIndex], @"SHIT");
    }
    
    else {
        STFail(@"Test not executed because unit under test not initialised");
    }
}

@end
