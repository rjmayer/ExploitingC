//
//  Using_C_ArraysTests.m
//  Using C ArraysTests
//
//  Created by Richard Mayer on 24/06/2013.
//  Copyright (c) 2013 Richard Mayer. All rights reserved.
//

#import "ExploitingCTests.h"

#import "NSDictionaryAsConst.h"

@implementation ExploitingCTests

- (void)setUp
{
    [super setUp];
    
    // Set-up code here.
}

- (void)tearDown
{
    // Tear-down code here.
    
    [super tearDown];
}

-(void)testEnumAndArrayConsistency
{
    NSLog(@"Testing the correct structure of enum FruitType...");
    
    NSUInteger fruitTypeCount = 0;
    for (FruitType userDataType = FruitTypeFirst;
         userDataType <= FruitTypeLast;
         ++userDataType)
    {
        fruitTypeCount++;
        // For the log out, knock 1 off the fruit type count, just so that the 
        // message "looks" correct. Although perfectly valid "Fruit typ 1 with
        // enum val 0" would seem wrong to the casual observer!)
        NSLog(@"Fruit type number %d has enum val %d", fruitTypeCount-1, userDataType);
    }
    
    // There is an ...Unknown enumeration = -1
    NSLog(@"FruitTypeUnknown = %d (expect -1)", FruitTypeUnknown);
    STAssertTrue(FruitTypeUnknown == -1, nil);
    
    // There is a ...First enumeration = 0
    NSLog(@"FruitTypeFirst = %d (expect 0)", FruitTypeFirst);
    STAssertTrue(FruitTypeFirst == 0, nil);
    
    // There is an ...Last enumeration > 0
    NSLog(@"FruitTypeLast = %d (expect 0 or larger)", FruitTypeLast);
    STAssertTrue(FruitTypeLast >= 0, nil);
    
    // Now compute the expected size of the array
    //
    // Note, we can't just use sizeof() because from here, the compiler can
    // only see in the .h:
    //   extern const FruitDefinition fruitDefsArray [];
    // It doesn't know how many elements.
    //
    // Alternatively I could have quite simply written in the .h
    // #define FRUIT_TYPES_COUNT 2
    // extern const FruitDefinition fruitDefsArray [FRUIT_TYPES_COUNT];
    //
    // But technically speaking that would be brittle. It would rely on the
    // dev, always updating it, after adding/removing enum types. And since
    // I've already gone to the effort of decking the enum out with a generic
    // type to use as an array sentinal, then it makes sense to use it here and
    // stay 100% dynamic.
    NSUInteger arraySize = 0;
    
    for (const FruitDefinition *fruitTypeDefn = fruitDefsArray;
         fruitTypeDefn->type != FruitTypeUnknown;
         ++fruitTypeDefn)
    {
        ++arraySize;
    }
    
    // Test that enumerations map onto the array of structs
    STAssertTrue(arraySize <= FruitTypeLast+1, @"Enum/array mismatch. Array size %d. Enum count %d - too few array elements", arraySize, fruitTypeCount);
    STAssertTrue(arraySize >= FruitTypeLast+1, @"Enum/array mismatch. Array size %d. Enum count %d - too few enumerations", arraySize, fruitTypeCount);
    STAssertTrue(arraySize == FruitTypeLast+1, @"Enumerations and array elements should map 1 to 1 but dont.");
    
    NSLog(@"There are %d fruit type enums defined, corresponding to %d array elements to store fruit descriptions", fruitTypeCount, arraySize);
}

- (void)testFruitTypeApple
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeApple];
    
    // The Test
    NSDictionaryAsConst* unitUnderTest = [[NSDictionaryAsConst alloc] init];
    
    NSDictionary* result = [unitUnderTest dictionaryForFruit:FruitTypeApple];
    
    // Evaluation 1
    // Check that the wrapper dict is correct
    STAssertNotNil([result objectForKey:fruitTypeIndex], @"SHIT");
    
    // Evaluation 2
    // Check that the contents are correc
    NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
    
    NSLog(@"FruitTypeApple's name is '%@' it's colour is '%@'",
          [fruitTypeDefn objectForKey:@"Name"],
          [fruitTypeDefn objectForKey:@"Colour"]);
}

- (void)testFruitTypeBanana
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeBanana];
    
    // The Test
    NSDictionaryAsConst* unitUnderTest = [[NSDictionaryAsConst alloc] init];
    
    NSDictionary* result = [unitUnderTest dictionaryForFruit:FruitTypeBanana];
    
    // Evaluation 1
    // Check that the wrapper dict is correct
    STAssertNotNil([result objectForKey:fruitTypeIndex], @"SHIT");
    
    // Evaluation 2
    // Check that the contents are correc
    NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
    
    NSLog(@"FruitTypeBanana's name is '%@' it's colour is '%@'",
          [fruitTypeDefn objectForKey:@"Name"],
          [fruitTypeDefn objectForKey:@"Colour"]);
}

- (void)testFruitTypeDefault
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeDefault];
    
    // The Test
    NSDictionaryAsConst* unitUnderTest = [[NSDictionaryAsConst alloc] init];
    
    NSDictionary* result = [unitUnderTest dictionaryForFruit:FruitTypeDefault];
    
    // Evaluation 1
    // Check that the wrapper dict is correct
    STAssertNotNil([result objectForKey:fruitTypeIndex], @"SHIT");
    
    // Evaluation 2
    // Check that the contents are correc
    NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
    
    NSLog(@"FruitTypeDefault's name is '%@' it's colour is '%@'",
          [fruitTypeDefn objectForKey:@"Name"],
          [fruitTypeDefn objectForKey:@"Colour"]);
}

- (void)testFruitTypeUnknown
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:FruitTypeUnknown];
    
    // The Test
    NSDictionaryAsConst* unitUnderTest = [[NSDictionaryAsConst alloc] init];
    
    NSDictionary* result = [unitUnderTest dictionaryForFruit:FruitTypeUnknown];
    
    // Evaluation 1
    // Check that the wrapper dict is correct
    STAssertNil([result objectForKey:fruitTypeIndex], @"SHIT");
    
    // Evaluation 2
    // Check that the contents are correc
    NSDictionary* fruitTypeDefn = [result objectForKey:fruitTypeIndex];
    
    NSLog(@"FruitTypeUnknown's name is '%@' it's colour is '%@'",
          [fruitTypeDefn objectForKey:@"Name"],
          [fruitTypeDefn objectForKey:@"Colour"]);
}

- (void)testFruitTypeInvalid
{
    // Test Condition
    NSNumber* fruitTypeIndex = [NSNumber numberWithInt:INT16_MIN];
    
    // The Test
    NSDictionaryAsConst* unitUnderTest = [[NSDictionaryAsConst alloc] init];
    
    NSDictionary* result = [unitUnderTest dictionaryForFruit:INT16_MIN];
    
    // Evaluation 1
    // Check that the wrapper dict is correct
    STAssertNil([result objectForKey:fruitTypeIndex], @"SHIT");
}

@end
